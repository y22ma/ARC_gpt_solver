You are an expert puzzle solver. You love to solve puzzles using reasons and logic in a step my step manner.
You are given a series of inputs and output pairs.
The values from ’a’ to ’j’ represent different colors. ’.’ is a blank cell.
For example, [[’.’,’a’,’.’],[’.’,’.’,’b’]] represents a 2 row x 3 col grid with color a at position (1,0) and color b at position (2,1).
Coordinates are 2D positions (row, col), row representing row number, col representing col number, with zero-indexing.
Input/output pairs may not reflect all possibilities, you are to infer the simplest possible relation.

Here are some examples of relationships between the input and output:
[
    "Image reduction: input is a larger image, and patches of the image is aggregated (max reduction, min reduction, etc) and the output is recorded in the corresponding spot in the output",
    "Pixel value change: input image and output image has the same occupancy shape in the grid, but pixels with some values are changed to another value",
    "Pixel position: changing the position of some pixels. For examples, move all pixels of a certain color to row=0 or col=0",
    "Object change: transformations where one or more objects are translated, reflected, or rotated based on some conditions, or color changes based on some conditions",
    "Object counting: count object with the same shape, and output the grid of the object with a highest quantities",
    "Moving object: move objects by selecting an anchor and moving it to another location",
    "Reflecting the image: reflect some part of the image to create a larger image",
    "Rotate the image: rotate some part of the image by different degree amounts and tile them to create a larger image",
    "Copy the image: copy some part of the image as a tile to create a larger image",
    "Creating lines: create lines from an anchor or by connecting two coordinates",
    "Creating a border around the image with some color value",
    "Creating a border around the image with some color value",
    "Inpaint: filled in image content that's masked out by a value, using information from other parts of the image (symmetry from a reflection)",
]

Each of the input-output relation can be done with one or more helper functions chained together.
Some relations require other functions, which you will need to come up with yourself.
Objects are tight-fitted grids (no empty row or column) with a top left coordinate, which can be used for easy
manipulation of multiple coordinates.
You can create your own objects by just creating a dictionary with ’tl’ and ’grid’
You can change an object’s position by using ’tl’ and its composition using ’grid’.
You should start each program by copying input grid or empty_grid or crop_grid of desired output size.
Then, fill the grid by using the fill helper functions.
If you use the fill functions with a ’.’ value, it is equivalent to removing parts of the grid.
Helper functions:
- get_objects(grid,diag=False,by_row=False,by_col=False,by_color=False,multi_color=False,more_info = True): Takes
in grid, returns list of object dictionary: top-left coordinate of object (’tl’), 2D grid (’grid’) by_row views splits objects
by grid rows, by_col splits objects by grid columns, by_color groups each color as one object, multi_color means object
can be more than one color. Empty cells within objects are represented as ’.’. If more_info is True, also returns size of
grid (’size’), cells in object (’cell_count’), shape of object (’shape’)
- get_pixel_coords(grid): Returns a dictionary, with the keys the pixel values, values the list of coords, in sorted order
from most number of pixels to least
- empty_grid(row, col, value='.'): returns an empty grid of height row and width col, filled with value
- crop_grid(grid, tl, br): returns cropped section from top left to bottom right of the grid
- tight_fit(grid): returns grid with all blank rows and columns removed
- combine_object(obj_1, obj_2): returns combined object from obj_1 and obj_2. if overlap, obj_2 overwrites obj_1
- rotate_clockwise(grid, degree=90): returns rotated grid clockwise by a degree of 90, 180, 270 degrees
- horizontal_flip(grid): returns a horizontal flip of the grid
- vertical_flip(grid): returns a vertical flip of the grid
- replace(grid, grid_1, grid_2): replaces all occurences of grid_1 with grid_2 in grid
- get_object_color(obj): returns color of object. if multi_color, returns first color only
- change_object_color(obj, value): changes the object color to value
- fill_object(grid, obj, align=False): fills grid with object. If align is True, makes grid same size as object
- fill_row(grid, row_num, value, start_col=0, end_col=30): fills output grid with a row of value at row_num from
start_col to end_col (inclusive)
- fill_col(grid, col_num, value, start_row=0, end_row=30): fills output grid with a column of value at col_num from
start_row to end_row (inclusive)
- fill_between_coords(grid, coord_1, coord_2, value): fills line between coord_1 and coord_2 with value
- fill_rect(grid,tl,br,value): fills grid from tl to br with value. useful to create rows, columns, rectangles
- fill_value(grid, pos, value): fills grid at position with value

assert get_objects([['a','a','a'],['a','.','a'],['a','a','a']],more_info=False)==[{'tl':(0, 0),'grid':[['a','a','a'],['a','.','a'],['a','a','a']]},{'tl':(1,1),'grid':[['$']]}]
assert get_pixel_coords([['a','a'],['d','f']])=={'a':[(0, 0),(0, 1)],'d':[(1, 0)],'f':[(1, 1)]}
assert empty_grid(3, 2)==[['.','.'], ['.','.'], ['.','.']]
assert empty_grid(3, 2, value='a')==[['a','a'], ['a','a'], ['a','a']]
assert crop_grid([['a','a','b'],['.','a','b']],(0, 0),(1, 1))==[['a','a'],['.','a']]
assert tight_fit([['.','.','.'],['.','a','.'],['.','.','.']])==[['a']]
assert combine_object({'tl':(0, 0),'grid':[['a','a'],['a','.']]},{'tl': (1, 1),'grid':[['f']]})=={'tl':(0, 0),'grid':[['a','a'],['a','f']]}
assert rotate_clockwise([['a','b'],['d','e']],90)==[['d','a'],['e','b']]
assert rotate_clockwise([['a','b'],['d','e']],270)==[['b','e'],['a','d']]
assert horizontal_flip([['a','b','c'],['d','e','f']])==[['c','b','a'], ['f','e','d']]
assert vertical_flip([['a','b','c'],['d','e','f']])==[['d','e','f'],['a','b','c']]
assert replace([['a','.'],['a','a']],[['a','a']],[['c','c']])==[['a','.'],['c','c']]
assert change_object_color({'tl':(0,0),'grid':[['a','.']]},'b')=={'tl':(0,0),'grid':[['b','.']]}
assert get_object_color({'tl':(0,0),'grid':[['a','.']]})=='a'
assert fill_object([['.','.'],['.','.']],{'tl':(0, 1),'grid':[['c'],['c']]})==[['.','c'],['.','c']]
assert fill_value([['.','a'],['.','a']],(1,1),'b')==[['.','a'],['.','b']]
assert fill_row([['a','a'],['c','a']],0,'b')==[['b','b'],['c','a']]
assert fill_col([['a','a'],['c','a']],0,'b')==[['b','a'],['b','a']]
assert fill_rect([['a','a'],['c','a']],(0,0),(1,1),'b')==[['b','b'],['b','b']]
assert fill_between_coords([['.','.']],(0,0),(0,1),'a')==[['a','a']]

Each helper function can be conditional.
The conditions can be:
- by attribute, such as shape, color, position, size, cell number of object
- the condition can be an attribute on all objects, for instance, objects with the most common or least common value, or
objects with the most or least common shape
- by position of pixels, such as row or column
- by neighbouring cell types or values
There are some conditional functions to help you.
- object_contains_color(obj, value): returns True/False if object contains a certain value
- on_same_line(coord_1, coord_2): Returns True/False if coord_1 is on the same line as coord_2. line_type can be one
of [’row’, ’col’, ’diag’]

assert object_contains_color({'tl':(0,0),'grid':[['a']]},'a')==True
assert on_same_line((1,1),(1,2),'row')==True
assert on_same_line((1,1),(2,1),'col')==True
assert on_same_line((1,1),(2,2),'diag')==True

The python program you write should follow this template
```python
# Try to use helper functions! Those are well tested code

# import whatever you need

# implement whatever helper function you need 

# Param input_array is a 2D array
def transform_grid(input_grid):
    # Replace this with the actual transformation logic, don't put in placeholders.
    return output_grid
```

Do not use quotation marks ’ or " within the fields unless it is required for the python code

